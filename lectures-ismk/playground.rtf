{\rtf1\ansi\ansicpg1252\cocoartf1343\cocoasubrtf160
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red170\green13\blue145;\red92\green38\blue153;
\red28\green0\blue207;\red38\green71\blue75;\red63\green110\blue116;\red46\green13\blue110;\red196\green26\blue22;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww16600\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs72 \cf2 \CocoaLigature0 //: Playground - noun: a place where people can play\
\pard\tx1780\pardeftab1780\pardirnatural\partightenfactor0
\cf0 \
\cf3 import\cf0  UIKit\
\cf2 /*\
//Veri T\'fcrleri\
\
\
//let lname = "Y\uc0\u305 lmaz"\
var age : Int = 28\
var age2 = 21\
//print("Ad\uc0\u305  : \\(name) Soyad\u305 : \\(lname) Ya\u351 \u305 : \\(age)")\
\
let n1 = 11\
let result = (n1 + 2) * 3\
\
//convert\
\
\
let integer : Int = 10\
let double : Double = 11.3\
//let result2 : Double = Double(integer * double)\
\
//\
let isEquals : Bool = (1 == 1)\
let isEquals2 : Bool = (1 < 1)\
let isEquals3 = (1 == 1) && true\
let isEquals4 = false || true\
\
////////////lesson 2 \
\
let hourOfDay = 12\
var timeOfDay : String\
let name = "Yunus"\
\
if hourOfDay < 6 \{\
    timeOfDay = "Early morning"\
\}else if hourOfDay < 12 \{\
    timeOfDay = "Afternon"\
\}\
else \{\
    timeOfDay = "Evening"\
\}\
 */\cf0 \
\cf2 /*\
print(" \\(timeOfDay)")\
\
if 1 < 2 && name == "Yunus" \{\
    //print("true")\
    if name == "Y\uc0\u305 lmaz" \{\
        print("")\
    \}\
    else \{\
        print("")\
    \}\
\}\
else \{\
    print("")\
\}\
if 3 == 3 || name == "Y\uc0\u305 lmaz" \{\
    print("veya")\
\}\
//scope kavram\uc0\u305 \
\
var houseWorked = 45\
\
var price = 0\
\
if houseWorked < 40 \{\
   // let houseWorked = houseWorked - 40 hata \'e7\'fcnk\'fc global scope local scope'u ezer.\
    price += houseWorked\
\}\
//? operator\
let a = 10\
let b : Int = 20\
\
let min = a < b ? a : b\
let max = a > b ? a : b\
\
//loops\
\
//while loop\
\
var sum = 1\
\
while sum < 10 \{\
    sum += 1\
    //print(sum)\
\}\
 */\cf0  \cf2 /*\
sum = 0\
repeat \{\
    print(sum)\
    sum += 1\
\} while sum == 0\
print(sum)\
\
while true \{\
    sum += 1\
    if sum >= 100 \{\
        break\
    \}\
    print(sum)\
\}\
*/\cf0 \
\
\cf2 //////////////////////////////////////////////\
///////////////////////15.05.2017\
/*\
let a = 5\
let b = 10\
\
let min : Int\
\
if a < b \{\
    min = a\
\}\
else\
\{\
    min = b\
\}\
\
/// \
/*\
E\uc0\u351 it de\u287 il : !=\
K\'fc\'e7\'fck / b\'fcy\'fck : <>\
K\'fc\'e7\'fck e\uc0\u351 it / b\'fcy\'fck e\u351 it : <= >=\
*/\
//Ranges \
\
\
let closedRange = 0...5 //0, 1, 2, 3, 4, 5\
\
//for loops \
\
let count = 10\
var sum = 0\
\
for i in 1...count \{\
    sum += i\
\}\
print(sum)\
\
for _ in 1...count \{\
    print("tag")\
\}\
\
for i in 1...count where i % 2 == 1 \{\
    print("where")\
\}\
print(sum)\
\
///\'f6rnek\
\
let row = 0\
let column = 0\
\
\
for row in 0..<8 \{\
    if row % 2 == 0 \{\
        continue\
    \}\
    \
    for column in 0..<8 \{\
        //print(row * column)\
    \}\
\}\
\
///\
for row in 0..<8 where row % 2 == 1\{\
    for column in 0..<8 \{\
        print(row * column)\
    \}\
\}\
//switch\
\
let numberForSwitch = 10\
\
switch numberForSwitch \{\
case 5, 10:\
    print("5 veya 10")\
default:\
    print("hicbiri")\
\}\
\
let nameForSwitch = "Dog"\
\
switch nameForSwitch \{\
case "Dog", "Cat":\
    print(nameForSwitch)\
case "bla" :\
    print(nameForSwitch)\
default:\
    print("Hi\'e7biri")\
\}\
\
switch numberForSwitch \{\
case 0...5: //with range\
    print(numberForSwitch)\
default:\
    print(numberForSwitch)\
\}\
\
switch numberForSwitch \{\
case _ where numberForSwitch % 2 == 0:\
    print("\'c7ift say\uc0\u305 ")\
default:\
    print("Tek say\uc0\u305 ")\
\}\
//functions\
\
func printMyName() \{\
    print("Yunus")\
\}\
\
\
printMyName()\
\
func sum(operand1: Int, operand2: Int) -> Int\{\
    return operand1 + operand2\
\}\
\
sum(operand1: 5, operand2: 20)\
//with tag\
func multply(first operand1: Int, last operand2: Int) -> Int \{\
    return operand1 * operand2\
\}\
\
func multply(_ operand1: Int, _ operand2: Int) -> Int \{\
    return operand1 * operand2\
\}\
\
multply(11, 22)\
\
//16.05.2015\
func multply2(_ operand1: Int, _ operand2: Int = 1) -> (Int, Int) \{\
    return (operand1 * operand2, operand2)\
\}\
//let result = multply2(5)\
let result = multply2(5, 10)\
result.0\
result.1\
//call by value and call by referance\
/*\
func incerementAndPrint(_ value: Int) \{\
    value += 1\
    print(value)\
\}\
 */\
var val = 5\
\
func incerementAndPrint(_  value: inout Int) \{\
    value += 1\
    print(value)\
\}\
\
incerementAndPrint(&val)\
print(val)\
\
//overloading \
\
func getValue() -> Int \{\
    return 11;\
\}\
func getValue() -> String \{\
    return "11"\
\}\
\
let resultForOver :String  = getValue()\
//17.05.2017 \
\
//function as veriable\
\
\
func add(_ a: Int, _ b:Int)->Int \{\
    return a + b\
\}\
var function = add\
\
\
function(5, 11)\
\
func printAndResult(_ function: (Int, Int) -> Int, _ a: Int, _ b: Int) \{\
    let result = function(a, b)\
    print(result)\
\}\
printAndResult(add, 5, 11)\
\
//no return\
\
func noResult()->Never \{\
    while true \{\
        print("asla d\'f6nmem")\
    \}\
    \
\}\
/*\
for index in add(5, 1) \{\
    print(index)\
\}\
*/\
*/\cf0 \
\
\cf3 func\cf0  fibonacci(\cf3 _\cf0  number: \cf4 Int\cf0 )->\cf4 Int\cf0  \{\
    \cf3 if\cf0  number <= \cf5 0\cf0  \{\
        \cf3 return\cf0  \cf5 0\cf0 \
    \}\
    \cf3 else\cf0  \cf3 if\cf0  number == \cf5 1\cf0  \{\
        \cf3 return\cf0  \cf5 1\cf0 \
    \}\
    \cf3 else\cf0  \{\
        \cf3 return\cf0  \cf6 fibonacci\cf0 (number - \cf5 1\cf0 ) + \cf6 fibonacci\cf0 (number - \cf5 2\cf0 )\
    \}\
\}\
\cf3 var\cf0  num = \cf5 1\cf0 \
\cf3 while\cf0  \cf7 num\cf0  != \cf5 5\cf0 \{\
    \cf8 print\cf0 (\cf6 fibonacci\cf0 (\cf7 num\cf0 ))\
    \cf7 num\cf0  += \cf5 1\cf0 \
\}\
\cf2 //optionals\
\cf3 var\cf0  name : \cf4 String\cf0 ?\
\cf7 name\cf0  = \cf3 nil\cf0 \
\cf2 //unwrapping\
//print(name ?? "Yunus")\
\cf0 \
\cf2 //optional binding\
\cf0 \
\cf2 //guard mechanism\
\cf3 if\cf0  \cf3 let\cf0  mName = \cf7 name\cf0 , let mName2 = \cf7 name\cf0  \{\
    \cf8 print\cf0 (mName)\
\}\
\cf3 else\cf0  \{\
    \cf8 print\cf0 (\cf9 ""\cf0 )\
\}\
\cf3 if\cf0  \cf7 name\cf0  != \cf3 nil\cf0  \{\
    \cf8 print\cf0 (\cf9 ""\cf0 )\
    \cf7 name\cf0 !\
\}\
\
\
\cf3 func\cf0  calculateFromSides(\cf3 _\cf0  side: \cf4 Int\cf0 ) -> \cf4 String\cf0 ? \{\
    \cf3 switch\cf0  side \{\
    \cf3 case\cf0  \cf5 3\cf0 :\
        \cf3 return\cf0  \cf9 "\'dc\'e7gen"\cf0 \
    \cf3 case\cf0  \cf5 4\cf0 :\
        \cf3 return\cf0  \cf9 "Kare"\cf0 \
    \cf3 default\cf0 :\
        \cf3 return\cf0  \cf3 nil\cf0 \
    \}\
 \
\}\
\
\cf3 if\cf0  \cf3 let\cf0  result:\cf4 String\cf0  = \cf6 calculateFromSides\cf0 (\cf5 5\cf0 ) \{\
    \cf8 print\cf0 (result)\
\}\
\cf3 else\cf0 \
\{\
    \cf8 print\cf0 (\cf6 calculateFromSides\cf0 (\cf5 5\cf0 ) ?? \cf9 "no result"\cf0 )\
\}\
\cf2 ////////////22.05.2017\
\cf0 \
\cf2 //Collection Types\
\cf0 \
\cf2 //1. Arrays\
\cf0 \
\cf3 let\cf0  evenNumbers = [\cf5 2\cf0 , \cf5 4\cf0 , \cf5 6\cf0 , \cf5 8\cf0 ]\
\
\cf3 var\cf0  subscribes : [\cf4 String\cf0 ] = []\
\
\cf3 var\cf0  allZero = [\cf4 Int\cf0 ] (repeating: \cf5 0\cf0 , count: \cf5 5\cf0 )\
\
\cf8 print\cf0 (\cf7 allZero\cf0 )\
\
\cf3 var\cf0  allZero2 : [\cf4 Int\cf0 ] = [\cf4 Int\cf0 ] (repeating: \cf5 0\cf0 , count: \cf5 15\cf0 )\
\
\cf8 print\cf0 (\cf7 allZero2\cf0 )\
\
\cf3 var\cf0  allZere3 = \cf4 Array\cf0 (repeating: \cf5 0\cf0 , count: \cf5 4\cf0 )\
\cf8 print\cf0 (\cf7 allZere3\cf0 )\
\
\cf3 let\cf0  stringSet = [\cf9 "A"\cf0 , \cf9 "E"\cf0 , \cf9 "T"\cf0 , \cf9 "G"\cf0 , \cf9 "R"\cf0 , \cf9 "F"\cf0 , \cf9 "Y"\cf0 , \cf9 "U"\cf0 ]\
\cf8 print\cf0 (\cf7 stringSet\cf0 )\
\
\cf3 var\cf0  players = [\cf9 "Ali"\cf0 , \cf9 "Ahmet"\cf0 , \cf9 "Selim"\cf0 , \cf9 "Engin"\cf0 ]\
\cf8 print\cf0 (\cf7 players\cf0 .\cf4 isEmpty\cf0 )\
\cf3 if\cf0  \cf7 players\cf0 .\cf4 count\cf0  < \cf5 2\cf0  \{\
    \cf8 print\cf0 (\cf9 "Eleman say\uc0\u305 s\u305  2 den k\'fc\'e7\'fck"\cf0 )\
\}\
\cf3 else\cf0  \{\
    \cf8 print\cf0 (\cf7 players\cf0 .\cf4 count\cf0 )\
\}\
\cf8 print\cf0 (\cf7 players\cf0 .\cf4 first\cf0 !)\
\cf8 print\cf0 (\cf7 players\cf0 .\cf4 last\cf0 !)\
\
\cf2 //methods in arrays\
\cf0 \
\cf3 let\cf0  minElement = \cf7 players\cf0 .\cf8 min\cf0 ()\
\
\cf3 if\cf0  \cf3 let\cf0  myElement = \cf7 minElement\cf0  \{\
    \cf8 print\cf0 (myElement)\
\}\
\
\cf8 print\cf0 ((\cf5 1\cf0 ...\cf5 5\cf0 ).\cf4 first\cf0 !)\
\cf8 print\cf0 ([\cf5 2\cf0 , \cf5 3\cf0 , \cf5 4\cf0 , \cf5 5\cf0 ].\cf8 min\cf0 ()!)\
\
\cf8 print\cf0 (\cf7 players\cf0 [\cf5 3\cf0 ])\
\
\
\cf3 var\cf0  upComingPlayer = \cf7 players\cf0 [\cf5 0\cf0 ...\cf5 2\cf0 ]\
\cf7 upComingPlayer\cf0 .\cf4 first\cf0 !\
\
\cf7 players\cf0 .\cf8 contains\cf0 (\cf9 "Ali"\cf0 ) \cf2 //check element\
\cf7 players\cf0 [\cf5 0\cf0 ...\cf5 2\cf0 ].\cf8 contains\cf0 (\cf9 "Ali"\cf0 )\
\
\cf7 players\cf0 .\cf8 append\cf0 (\cf9 "Ay\uc0\u351 e"\cf0 )\cf2 //sonuna eleman ekleme\
\cf7 players\cf0  += [\cf9 "Serpil"\cf0 ]\
\
\cf7 players\cf0 .\cf8 insert\cf0 (\cf9 "Kamil"\cf0 , at: \cf5 5\cf0 )\cf2 //verilen index'e ekleme\
\cf0 \
\cf7 players\cf0 .\cf8 removeFirst\cf0 ()\
\cf7 players\cf0 .\cf8 removeLast\cf0 ()\
\cf7 players\cf0 .\cf8 remove\cf0 (at: \cf5 4\cf0 )\
\cf8 print\cf0 (\cf7 players\cf0 )\
\
\cf7 players\cf0 [\cf5 3\cf0 ] = \cf9 "Serpil"\cf0  \cf2 //updated\
\cf8 print\cf0 (\cf7 players\cf0 )\
\
\cf7 players\cf0 [\cf5 0\cf0 ...\cf5 1\cf0 ] = [\cf9 "Dogan"\cf0 , \cf9 "Asl\uc0\u305 "\cf0 , \cf9 "Halil"\cf0 , \cf9 "Mehmet"\cf0 ]\cf2 //range'e bak\uc0\u305 lmad\u305 .\
\cf8 print\cf0 (\cf7 players\cf0 )\
\
\cf7 players\cf0 .\cf8 sort\cf0 ()\
\cf8 print\cf0 (\cf7 players\cf0 )\
\cf7 players\cf0 .\cf8 index\cf0 (of: \cf9 "Asl\uc0\u305 "\cf0 )!\
\
\
\
\cf3 func\cf0  searchAndIndex(\cf3 _\cf0  element: \cf4 String\cf0 ) -> (\cf4 Int\cf0 , \cf4 String\cf0 )\{\
    \cf3 if\cf0  \cf8 !\cf0 (\cf7 players\cf0 .\cf8 contains\cf0 (element)) \{\
        \cf7 players\cf0 .\cf8 append\cf0 (element)\
        \cf7 players\cf0 .\cf8 sort\cf0 ()\
    \}\
    \
    \cf3 return\cf0  (\cf7 players\cf0 .\cf8 index\cf0 (of: element)!, element)\
\}\
\
\cf3 let\cf0  result = \cf6 searchAndIndex\cf0 (\cf9 "Ali"\cf0 )\
\cf8 print\cf0 (\cf7 result\cf0 .\cf5 0\cf0 , \cf7 result\cf0 .\cf5 1\cf0 )\
\
\cf2 //iterations\
\cf3 var\cf0  temp:\cf4 String\cf0  = \cf9 ""\cf0 \
\cf3 for\cf0  item \cf3 in\cf0  \cf7 players\cf0  \{\
    \cf7 temp\cf0  = \cf7 temp\cf0  \cf8 +\cf0  \cf9 " "\cf0  \cf8 +\cf0  item\
\}\
\cf8 print\cf0 (\cf7 temp\cf0 )\
\
\cf3 for\cf0  (index, value) \cf3 in\cf0  \cf7 players\cf0 .\cf8 enumerated\cf0 () \{\
    \cf8 print\cf0 (\cf9 "\cf0 \\\cf9 (\cf0 index + \cf5 1\cf9 ). \cf0 \\\cf9 (\cf0 value\cf9 )"\cf0 )\
\}\
\
\cf3 func\cf0  sumAllItems(in array:[\cf4 Int\cf0 ]) -> \cf4 Int\cf0  \{\
    \cf3 var\cf0  sum = \cf5 0\cf0 \
    \cf3 for\cf0  number \cf3 in\cf0  array \{\
        sum += number\
    \}\
    \cf3 return\cf0  sum\
\}\
\cf3 let\cf0  ages : [\cf4 Int\cf0 ] = [\cf5 155\cf0 , \cf5 11\cf0 , \cf5 22\cf0 , \cf5 66\cf0 , \cf5 32\cf0 , \cf5 28\cf0 , \cf5 0\cf0 ]\
\cf8 print\cf0 (\cf6 sumAllItems\cf0 (in: \cf7 ages\cf0 ))\
\
\cf2 //variadic parameters\
\cf0 \
\cf3 func\cf0  sum(of numbers: \cf4 Int\cf0 ...) -> \cf4 Int\cf0  \{\
    \cf3 var\cf0  total = \cf5 0\cf0 \
    \cf3 for\cf0  number \cf3 in\cf0  numbers \{\
        total += number\
    \}\
    \cf3 return\cf0  total\
\}\
\
\cf6 sum\cf0 (of: \cf5 1\cf0 , \cf5 6\cf0 , \cf5 44\cf0 , \cf5 55\cf0 )\
\cf2 /* d\'fczenlenecek\
func mySort(of numbers: Int...) \{\
    var temp = -1\
    var count = 0\
    let mySortedArray:[Int] = numbers\
    var repeatCount = numbers.count\
    while repeatCount > 0\
    \{\
        for number in mySortedArray \{\
            if count == 0 \{\
                temp = number\
            \}\
            if number < temp \{\
                temp = number\
                \
            \}\
            \
            count += 1\
        \}\
        repeatCount -= 1\
    \}\
    print(mySortedArray)\
\}\
mySort(of: 1, 0, 12, 11)\
*/\cf0 \
\cf2 ////////23.05.2017\
//dictionary\
\cf0 \
\cf3 var\cf0  namesAndScore = [\cf9 "Ali"\cf0  : \cf5 2\cf0 , \cf9 "Selim"\cf0  : \cf5 4\cf0 , \cf9 "Yavuz"\cf0  : \cf5 11\cf0 , \cf9 "Kemal"\cf0  : \cf5 6\cf0 ]\
\cf8 print\cf0 (\cf7 namesAndScore\cf0 )\
\cf3 let\cf0  namesAndScoreImplicit : [\cf4 String\cf0 :\cf4 Int\cf0 ] = [\cf9 "Ali"\cf0  : \cf5 2\cf0 , \cf9 "Selim"\cf0  : \cf5 4\cf0 , \cf9 "Yavuz"\cf0  : \cf5 11\cf0 , \cf9 "Kemal"\cf0  : \cf5 6\cf0 ]\
\
\cf3 var\cf0  score : [\cf4 String\cf0 :\cf4 Int\cf0 ] = [:]\
\
\cf8 print\cf0 (\cf7 namesAndScore\cf0 [\cf9 "Yavuz"\cf0 ]!)\
\
\cf2 //property and method\
\cf0 \
\cf7 namesAndScore\cf0 .\cf4 isEmpty\cf0 \
\cf7 namesAndScore\cf0 .\cf4 count\cf0 \
\
\cf4 Array\cf0 (\cf7 namesAndScore\cf0 .\cf4 keys\cf0 )\
\cf4 Array\cf0 (\cf7 namesAndScore\cf0 .\cf4 values\cf0 )\
\
\cf7 namesAndScore\cf0 .\cf8 updateValue\cf0 (\cf5 44\cf0 , forKey: \cf9 "Ali"\cf0 )\
\cf8 print\cf0 (\cf7 namesAndScore\cf0 )\
\cf7 namesAndScore\cf0 [\cf9 "Selim"\cf0 ] = \cf5 3\cf0 \
\cf8 print\cf0 (\cf7 namesAndScore\cf0 )\
\
\cf7 namesAndScore\cf0 .\cf8 removeValue\cf0 (forKey: \cf9 "Kemal"\cf0 )\
\cf8 print\cf0 (\cf7 namesAndScore\cf0 )\
\
\cf7 namesAndScore\cf0 [\cf9 "Ali"\cf0 ] = \cf3 nil\cf0 \
\cf8 print\cf0 (\cf7 namesAndScore\cf0 )\
\
\
\cf2 //iterating\
\cf0 \
\cf3 for\cf0  (key, value) \cf3 in\cf0  \cf7 namesAndScore\cf0  \{\
    \cf8 print\cf0 (\cf9 "\cf0 \\\cf9 (\cf0 key\cf9 ) - \cf0 \\\cf9 (\cf0 value\cf9 )"\cf0 )\
\}\
\cf3 for\cf0  key \cf3 in\cf0  \cf7 namesAndScore\cf0 .\cf4 keys\cf0  \{\
    \cf8 print\cf0 (key)\
\}\
\cf3 for\cf0  val \cf3 in\cf0  \cf7 namesAndScore\cf0 .\cf4 values\cf0  \{\
    \cf8 print\cf0 (val)\
\}\
\cf8 print\cf0 (\cf3 false\cf0 .\cf4 hashValue\cf0 )\
\cf8 print\cf0 (\cf5 10\cf0 .\cf4 hashValue\cf0 )\
\cf8 print\cf0 (\cf9 "Yunus"\cf0 .\cf4 hashValue\cf0 )\
\
\cf2 //\
\cf0 \
\cf3 var\cf0  myDict:[\cf4 Int\cf0 :\cf4 String\cf0 ] = [\cf5 34\cf0 :\cf9 "Istanbul"\cf0 , \cf5 06\cf0 :\cf9 "Ankara"\cf0 , \cf5 35\cf0 :\cf9 "Izmir"\cf0 ]\
\cf3 var\cf0  myDict2:[\cf4 Int\cf0 :\cf4 String\cf0 ] = [\cf5 34\cf0 :\cf9 "Istanbul1"\cf0 , \cf5 06\cf0 :\cf9 "Ankara2"\cf0 , \cf5 17\cf0 :\cf9 "\'c7anakkale"\cf0 , \cf5 41\cf0 :\cf9 "Kocaeli"\cf0 ]\
\cf3 func\cf0  findAndAddInMyDict(in myDictKey: \cf4 Int\cf0 , and Value: \cf4 String\cf0 ) -> (\cf4 Int\cf0 , \cf4 String\cf0 ) \{\
    \cf3 for\cf0  (key, value) \cf3 in\cf0  \cf7 myDict\cf0  \{\
        \cf3 if\cf0  key == myDictKey \{\
            \cf3 return\cf0  (key, value)\
        \}\
    \}\
    \cf7 myDict\cf0 [myDictKey] = Value\
    \cf3 return\cf0  (myDictKey, Value)\
\}\
\
\cf6 findAndAddInMyDict\cf0 (in: \cf5 01\cf0 , and: \cf9 "Adana"\cf0 )\
\cf8 print\cf0 (\cf7 myDict\cf0 )\
\
\cf3 func\cf0  mergeDict(\cf3 _\cf0  firstDict: \cf3 inout\cf0  [\cf4 Int\cf0 :\cf4 String\cf0 ], secondDict: [\cf4 Int\cf0 :\cf4 String\cf0 ])->\cf4 Bool\cf0  \{\
    \cf3 var\cf0  flag = \cf3 false\cf0 \
    \cf3 for\cf0  (key, val) \cf3 in\cf0  secondDict \{\
        \cf3 if\cf0  firstDict.\cf8 index\cf0 (forKey: key) == \cf3 nil\cf0 \
        \{\
            firstDict[key] = val\
            flag = \cf3 true\cf0 \
        \}\
    \}\
    \cf3 return\cf0  flag\
\}\
\
\cf3 if\cf0  \cf6 mergeDict\cf0 (&\cf7 myDict\cf0 , secondDict: \cf7 myDict2\cf0 ) \{\
    \cf8 print\cf0 (\cf7 myDict\cf0 )\
\}\
\cf2 //clouser\
\cf0 \
\cf3 var\cf0  multiplyCloser:(\cf4 Int\cf0 , \cf4 Int\cf0 ) -> \cf4 Int\cf0  \cf2 //decleration\
\cf0 \
\cf7 multiplyCloser\cf0  = \{ (a: \cf4 Int\cf0 , b:\cf4 Int\cf0 ) -> \cf4 Int\cf0  \cf3 in\cf0  \cf2 //implementation\
\cf0     \cf3 return\cf0  a * b\
\}\
\cf3 let\cf0  closerResult = \cf7 multiplyCloser\cf0 (\cf5 10\cf0 , \cf5 2\cf0 )\
\
\cf2 //\
\cf3 var\cf0  addCloser = \{(a: \cf4 Int\cf0 , b:\cf4 Int\cf0 ) -> \cf4 Int\cf0  \cf3 in\cf0  \cf2 //bildirim ve tan\uc0\u305 mlama\
\cf0     \cf3 return\cf0  a + b\
\}\
\cf7 addCloser\cf0 (\cf5 5\cf0 , \cf5 2\cf0 )\
\
\cf2 //\
/*\
var addCloser2 = \{(a: Int, b:Int) -> Int in //bildirim ve tan\uc0\u305 mlama\
    a + b\
\}\
\
var addCloser3 = \{(a: Int, b:Int)  in //bildirim ve tan\uc0\u305 mlama\
    a + b\
\}\
\
var addCloser4 = \{(a, b)  in //bildirim ve tan\uc0\u305 mlama\
    a + b\
\}\
\
var addCloser5 = \{ //bildirim ve tan\uc0\u305 mlama\
    $0 + $1\
\}\
*/\cf0 \
\cf3 func\cf0  operationsOnNumber(\cf3 _\cf0  a: \cf4 Int\cf0 , b: \cf4 Int\cf0 , operation: (\cf4 Int\cf0 , \cf4 Int\cf0 )->\cf4 Int\cf0 )->\cf4 Int\cf0  \{\
    \cf3 let\cf0  result = operation(a, b)\
    \cf8 print\cf0 (result)\
    \cf3 return\cf0  result\
\}\
\cf3 let\cf0  add = \{ (a: \cf4 Int\cf0 , b: \cf4 Int\cf0 )->\cf4 Int\cf0  \cf3 in\cf0 \
    \cf3 if\cf0  b == \cf5 0\cf0  \{\
        \cf3 return\cf0  a + (b + \cf5 1\cf0 )\
    \}\
    \cf3 return\cf0  a + b\
\}\
\cf3 let\cf0  multiply = \{(a:\cf4 Int\cf0 , b: \cf4 Int\cf0 ) \cf3 in\cf0 \
    \cf3 return\cf0  a * b\
\}\
\cf3 let\cf0  divide = \{(a: \cf4 Int\cf0 , b: \cf4 Int\cf0 )->\cf4 Int\cf0  \cf3 in\cf0 \
    \cf3 return\cf0  a / b\
\}\
\cf6 operationsOnNumber\cf0 (\cf5 12\cf0 , b: \cf5 0\cf0 , operation: \cf7 add\cf0 )\
\cf6 operationsOnNumber\cf0 (\cf5 12\cf0 , b: \cf5 2\cf0 , operation: \cf7 multiply\cf0 )\
\cf6 operationsOnNumber\cf0 (\cf5 12\cf0 , b: \cf5 3\cf0 , operation: \cf7 divide\cf0 )\
\cf2 //\
\cf0 \
\cf6 operationsOnNumber\cf0 (\cf5 11\cf0 , b: \cf5 22\cf0 , operation: \{(a:\cf4 Int\cf0 , b:\cf4 Int\cf0 )-> \cf4 Int\cf0  \cf3 in\cf0  \cf3 return\cf0  a + b\
\})\
\cf6 operationsOnNumber\cf0 (\cf5 11\cf0 , b: \cf5 22\cf0 , operation: \{ $0 + $1\})\
\cf6 operationsOnNumber\cf0 (\cf5 4\cf0 , b: \cf5 2\cf0 ) \{$0 + $1\}\
\cf2 //24.05.2017 \
//Clouser'a devam\
\cf0 \
\cf2 //scope\
\cf0 \
\cf3 var\cf0  count = \cf5 0\cf0 \
\
\cf3 let\cf0  incerementCount = \{\
    \cf7 count\cf0  += \cf5 1\cf0 \
\}\
\
\cf7 incerementCount\cf0 ()\
\cf7 incerementCount\cf0 ()\
\cf7 incerementCount\cf0 ()\
\cf7 incerementCount\cf0 ()\
\cf8 print\cf0 (\cf7 count\cf0 )\
\
\cf3 func\cf0  countingCloser()->(()->\cf4 Int\cf0 ) \{\
    \cf3 var\cf0  count = \cf5 0\cf0 \
    \cf3 let\cf0  incCount:()->\cf4 Int\cf0  = \{\
        count += \cf5 1\cf0 \
        \cf3 return\cf0  count\
    \}\
    \cf3 return\cf0  incCount\
\}\
\
\cf3 let\cf0  counter1 = \cf6 countingCloser\cf0 ()\
\cf7 counter1\cf0 ()\
\
\cf2 //custom methods with closures\
\cf3 let\cf0  names = [\cf9 "ZZZZZZZZ"\cf0 , \cf9 "BB"\cf0 , \cf9 "A"\cf0 , \cf9 "CCCC"\cf0 , \cf9 "EEEEE"\cf0 ]\
\cf7 names\cf0 .\cf8 sorted\cf0 ()\
\
\cf7 names\cf0 .\cf8 sorted\cf0  \{\
    $0.\cf4 characters\cf0 .\cf4 count\cf0  > $1.\cf4 characters\cf0 .\cf4 count\cf0 \
\}\
\
\cf3 var\cf0  prices = [\cf5 1.5\cf0 , \cf5 10\cf0 , \cf5 4.99\cf0 , \cf5 2.30\cf0 , \cf5 8.19\cf0 ]\
\
\cf3 let\cf0  largePrices = \cf7 prices\cf0 .\cf8 filter\cf0  \{\
    \cf3 return\cf0  $0 > \cf5 5\cf0 \
\}\
\
\cf3 let\cf0  salePrices = \cf7 prices\cf0 .\cf8 map\cf0 \{\
    \cf3 return\cf0  $0 * \cf5 0.9\cf0 \
\}\
\
\cf3 let\cf0  sum = \cf7 prices\cf0 .\cf8 reduce\cf0 (\cf5 0\cf0 ) \{\
    \cf3 return\cf0  $0 + $1 * \cf5 18\cf0 \
\}\
\cf7 salePrices\cf0 \
\cf7 sum\cf0 \
\
\cf2 //prices.dropFirst(2)\
//prices.dropLast(1)\
//prices.prefix(2)\
//prices.suffix(1)\
\cf0 \
\cf2 //yap\uc0\u305 lar\
\cf0 \
\cf3 struct\cf0  Location \{\
    \cf3 let\cf0  x: \cf4 Int\cf0 \
    \cf3 let\cf0  y: \cf4 Int\cf0 \
\}\
\
\cf3 var\cf0  myLocation = \cf7 Location\cf0 (x: \cf5 10\cf0 , y: \cf5 15\cf0 )\
\cf7 myLocation\cf0 .\cf7 x\cf0 \
\cf7 myLocation\cf0 .\cf7 y\cf0 \
\
\cf3 struct\cf0  Person \{\
    \cf3 let\cf0  name : \cf4 String\cf0 \
    \cf3 let\cf0  lname : \cf4 String\cf0 \
    \cf3 let\cf0  age : \cf4 Int\cf0 \
    \cf3 let\cf0  price : \cf4 Int\cf0 \
    \
\}\
\
\cf3 var\cf0  person1 = \cf7 Person\cf0 (name: \cf9 "Yunus"\cf0 , lname: \cf9 "Y\uc0\u305 lmaz"\cf0 , age: \cf5 28\cf0 , price: \cf5 1000\cf0 )\
\cf3 var\cf0  person2 = \cf7 Person\cf0 (name: \cf9 "Yunus2"\cf0 , lname: \cf9 "Y\uc0\u305 lmaz"\cf0 , age: \cf5 28\cf0 , price: \cf5 1000\cf0 )\
\
\cf2 //30.05.2017\
//methods in structs\
\cf3 let\cf0  storeLocation = \cf7 Location\cf0 (x: \cf5 2\cf0 , y:\cf5 4\cf0 )\
\
\cf3 func\cf0  distance(from source: (x: \cf4 Int\cf0 , y: \cf4 Int\cf0 ), to target: (x: \cf4 Int\cf0 , y: \cf4 Int\cf0 ))->\cf4 Double\cf0  \{\
    \cf3 let\cf0  distanceX = \cf4 Double\cf0 (source.x - target.x)\
    \cf3 let\cf0  distanceY = \cf4 Double\cf0 (source.y - target.y)\
    \
    \cf3 return\cf0  \cf8 sqrt\cf0 (distanceX * distanceX + distanceY * distanceY)\
\}\
\
\cf3 struct\cf0  DeliveryArea: \cf4 CustomStringConvertible\cf0  \{\
    \cf3 var\cf0  range:\cf4 Double\cf0 \
    \cf3 let\cf0  center:\cf7 Location\cf0 \
    \
    \cf3 var\cf0  description: \cf4 String\cf0  \{\
        \cf3 return\cf0  \cf9 "Area with range: \cf0 \\\cf9 (\cf7 range\cf9 ) Location: \cf0 \\\cf9 (\cf7 center\cf9 )"\cf0 \
    \}\
    \
    \cf3 func\cf0  isInDeliveryArea(\cf3 _\cf0  location: \cf7 Location\cf0 )->\cf4 Bool\cf0  \{\
        \cf3 for\cf0  area \cf3 in\cf0  \cf7 areas\cf0  \{\
            \cf3 let\cf0  distanceToStore = \cf6 distance\cf0 (from: (area.\cf7 center\cf0 .\cf7 x\cf0 , area.\cf7 center\cf0 .\cf7 y\cf0 ), to: (location.\cf7 x\cf0 , location.\cf7 y\cf0 ))\
            \cf3 if\cf0  distanceToStore < \cf7 range\cf0  \{\
                \cf3 return\cf0  \cf3 true\cf0 \
            \}\
        \}\
       \cf3 return\cf0  \cf3 false\cf0 \
    \}\
\}\
\cf3 let\cf0  areas = [\cf7 DeliveryArea\cf0 (range: \cf5 2.5\cf0 , center: \cf7 Location\cf0 (x:\cf5 2\cf0 , y:\cf5 4\cf0 )), \cf7 DeliveryArea\cf0 (range: \cf5 4.5\cf0 , center: \cf7 Location\cf0 (x: \cf5 9\cf0 , y: \cf5 7\cf0 ))]\
\
\cf3 var\cf0  storeArea = \cf7 DeliveryArea\cf0 (range:\cf5 4\cf0 , center: \cf7 storeLocation\cf0 )\
\
\cf3 let\cf0  customerLocation1 = \cf7 Location\cf0 (x: \cf5 8\cf0 , y: \cf5 1\cf0 )\
\cf3 let\cf0  customerLocation2 = \cf7 Location\cf0 (x: \cf5 2\cf0 , y: \cf5 4\cf0 )\
\
\cf8 print\cf0 (\cf7 storeArea\cf0 .\cf6 isInDeliveryArea\cf0 (\cf7 customerLocation1\cf0 ))\
\cf8 print\cf0 (\cf7 storeArea\cf0 .\cf6 isInDeliveryArea\cf0 (\cf7 customerLocation2\cf0 ))\
\
\cf3 struct\cf0  Student \{\
    \cf3 var\cf0  age : \cf4 Int\cf0 \
    \cf3 var\cf0  name : \cf4 String\cf0 \
    \
    \cf3 func\cf0  getAgeAndName()->(\cf4 Int\cf0 , \cf4 String\cf0 ) \{\
        \cf3 return\cf0  (\cf7 age\cf0 , \cf7 name\cf0 )\
    \}\
\}\
\cf3 var\cf0  std1 = \cf7 Student\cf0 (age: \cf5 11\cf0 , name: \cf9 "Berkecan"\cf0 )\
\cf8 print\cf0 (\cf7 std1\cf0 .\cf6 getAgeAndName\cf0 ())\
\
\cf2 /*\
public struct Int : SignedInteger, Comparable, Equatable \{\
    //...\
\}\
*/\cf0 \
\cf2 /*public protocol CustomStringConvertible \{\
    public var description: String \{get\}\
\}\
*/\cf0 \
\
\cf3 typealias\cf0  BoardPrice = \cf4 String\cf0 \
\cf3 let\cf0  x : \cf7 BoardPrice\cf0  = \cf9 "X"\cf0 \
\
\
\
\cf2 //properties\
\cf0 \
\cf3 struct\cf0  Contact \{\
    \cf3 var\cf0  fullName: \cf4 String\cf0  = \cf9 ""\cf0  \cf2 //default value\
\cf0     \cf3 var\cf0  email: \cf4 String\cf0  = \cf9 ""\cf0 \
\}\
\cf3 var\cf0  myContact = \cf7 Contact\cf0 ()\
\cf7 myContact\cf0 .\cf7 email\cf0  = \cf9 "yunus@yunus.com"\cf0 \
\cf7 myContact\cf0 .\cf7 fullName\cf0  = \cf9 "yunus"\cf0 \
\
\cf3 struct\cf0  Diagonal \{\
    \cf3 var\cf0  height: \cf4 Double\cf0  = \cf5 0\cf0 \
    \cf3 var\cf0  width :\cf4 Double\cf0  = \cf5 0\cf0 \
    \
    \cf3 var\cf0  diagonal : \cf4 Int\cf0  \{\
        \cf3 get\cf0  \{\
            \cf3 let\cf0  result = \cf8 sqrt\cf0 (\cf7 height\cf0  * \cf7 height\cf0  + \cf7 width\cf0  * \cf7 width\cf0 )\
            \cf3 return\cf0  \cf4 Int\cf0 (result.\cf8 rounded\cf0 ())\
        \}\
        \cf3 set\cf0  \{\
            \cf7 width\cf0  = \cf4 Double\cf0 (newValue)\
        \}\
    \}\
    \cf3 var\cf0  heightSq : \cf4 Double\cf0  \{\
        \cf3 return\cf0  \cf7 height\cf0  * \cf7 height\cf0 \
    \}\
\}\
\cf3 var\cf0  diagonal1 = \cf7 Diagonal\cf0 (height: \cf5 53.9\cf0 , width: \cf5 95.87\cf0 )\
\cf8 print\cf0 (\cf7 diagonal1\cf0 .\cf7 diagonal\cf0 )\cf2 //property nin get b\'f6l\'fcm\'fc \'e7al\uc0\u305 \u351 t\u305 \
\cf7 diagonal1\cf0 .\cf7 diagonal\cf0  = \cf5 10\cf0  \cf2 //property nin set b\'f6l\'fcm\'fc \'e7al\uc0\u305 \u351 t\u305 r ve 10 de\u287 eri newValue'a atand\u305 \
\cf7 diagonal1\cf0 .\cf7 width\cf0 \
\
\cf2 //static veriable\
\cf3 struct\cf0  LightBulb \{\
    \cf3 static\cf0  \cf3 let\cf0  maxCurrent = \cf5 40\cf0 \
    \cf3 var\cf0  name = \cf9 "Spot Light"\cf0 \
\}\
\cf8 print\cf0 (\cf7 LightBulb\cf0 .\cf7 maxCurrent\cf0 )\
\
\cf2 //////////////31.05.2017\
//property observers\
\cf0 \
\cf3 struct\cf0  Level \{\
    \cf3 static\cf0  \cf3 var\cf0  highesLevel = \cf5 1\cf0 \
    \cf3 let\cf0  id: \cf4 Int\cf0 \
    \cf3 var\cf0  boss: \cf4 String\cf0 \
    \cf3 var\cf0  unlocked : \cf4 Bool\cf0  \{\
        \cf3 willSet\cf0  \{\
            \cf8 print\cf0 (\cf9 "willSet and id:\cf0 \\\cf9 (\cf7 id\cf9 )"\cf0 )\
        \}\
        \cf3 didSet\cf0  \{\
            \cf3 if\cf0  \cf7 unlocked\cf0  \cf8 &&\cf0  \cf7 id\cf0  > \cf7 Level\cf0 .\cf7 highesLevel\cf0  \{\
                \cf8 print\cf0 (\cf9 "didSet and id:\cf0 \\\cf9 (\cf7 id\cf9 )"\cf0 )\
                \cf7 Level\cf0 .\cf7 highesLevel\cf0  = \cf7 id\cf0 \
                \cf8 print\cf0 (oldValue)\
            \}\
        \}\
    \}\
    \
\}\
\cf3 var\cf0  bolum1 = \cf7 Level\cf0 (id: \cf5 2\cf0 , boss: \cf9 "B\'f6l\'fcm1"\cf0 , unlocked: \cf3 false\cf0 )\cf2 //property observers not working\
\cf7 bolum1\cf0 .\cf7 unlocked\cf0  = \cf3 true\cf0 \
\
\
\cf2 //lazy property bak\uc0\u305 lacak\
\cf0 \
\cf3 struct\cf0  myPerson \{\
    \cf3 var\cf0  age = \cf5 16\cf0 \
    \
    \cf3 lazy\cf0  \cf3 var\cf0  fibonacciAge : \cf4 Int\cf0  = \{\
        \cf3 return\cf0  \cf6 fibonacci\cf0 (\cf3 self\cf0 .\cf7 age\cf0 )\
    \}()\
\}\
\cf3 var\cf0  myPerson1 = \cf7 myPerson\cf0 ()\
\cf8 print\cf0 (\cf7 myPerson\cf0 .\cf3 init\cf0 (age: \cf5 15\cf0 , fibonacciAge: \cf5 15\cf0 ))\
\
\
\cf2 //methods samples\
\cf3 let\cf0  months = [\cf9 "Ocak"\cf0 , \cf9 "\uc0\u350 ubat"\cf0 , \cf9 "Mart"\cf0 , \cf9 "Nisan"\cf0 , \cf9 "May\uc0\u305 s"\cf0 , \cf9 "Haziran"\cf0 , \cf9 "Temmuz"\cf0 , \cf9 "A\uc0\u287 ustos"\cf0 , \cf9 "Eyl\'fcl"\cf0 , \cf9 "Ekim"\cf0 , \cf9 "Kas\uc0\u305 m"\cf0 , \cf9 "Aral\uc0\u305 k"\cf0 ]\
\cf2 //init methods\
\cf3 struct\cf0  SimpleDate \{\
    \cf3 var\cf0  month: \cf4 String\cf0 \
    \cf3 var\cf0  day: \cf4 Int\cf0  = \cf5 0\cf0 \
    \
    \cf3 init\cf0 () \{\
        \cf7 month\cf0  = \cf9 ""\cf0 \
    \}\
    \cf3 init\cf0 (\cf3 _\cf0  month : \cf4 String\cf0 ) \{\
        \cf3 self\cf0 .\cf7 month\cf0  = month\
    \}\
    \cf3 func\cf0  monthsUntil(from date: \cf7 SimpleDate\cf0 ) -> \cf4 Int\cf0  \{\
        \cf3 return\cf0  \cf7 months\cf0 .\cf8 index\cf0 (of: \cf9 "Aral\uc0\u305 k"\cf0 )! - \cf7 months\cf0 .\cf8 index\cf0 (of: date.\cf7 month\cf0 )! \cf2 //self.month\
\cf0     \}\
    \cf2 //mutating in methods\
\cf0     \cf3 mutating\cf0  \cf3 func\cf0  advance()\
    \{\
        \cf7 day\cf0  += \cf5 1\cf0 \
        \cf8 print\cf0 (\cf9 "day: \cf0 \\\cf9 (\cf7 day\cf9 )"\cf0 )\
    \}\
\}\
\cf3 var\cf0  date = \cf7 SimpleDate\cf0 (\cf9 "Ocak"\cf0 )\
\cf3 let\cf0  monthsLeft = \cf7 date\cf0 .\cf6 monthsUntil\cf0 (from: \cf7 date\cf0 )\
\cf7 date\cf0 .\cf6 advance\cf0 ()\
\cf7 date\cf0 .\cf6 advance\cf0 ()\
\
\cf2 //static in methods \
\cf0 \
\cf3 struct\cf0  Math \{\
    \cf3 var\cf0  m_number : \cf4 Int\cf0  = \cf5 0\cf0 \
    \cf3 static\cf0  \cf3 func\cf0  factorial(of number: \cf4 Int\cf0 ) ->\cf4 Int\cf0  \{\
        \cf3 return\cf0  (\cf5 1\cf0 ...number).\cf8 reduce\cf0 (\cf5 1\cf0 ) \{\
            \cf3 return\cf0  $0 * $1\
            \
        \}\
    \}\
\}\
\cf3 let\cf0  factorial = \cf7 Math\cf0 .\cf6 factorial(of: 3)\cf0 \
\
\
\cf3 extension\cf0  \cf7 SimpleDate\cf0  \{\
    \cf3 init\cf0 (from day: \cf4 Int\cf0 ) \{\
        \cf3 self\cf0 .\cf7 day\cf0  = day\
        \cf3 self\cf0 .\cf7 month\cf0  = \cf9 ""\cf0 \
    \}\
\}\
\
\cf3 let\cf0  simpleDate2 = \cf7 SimpleDate\cf0 (from: \cf5 1\cf0 )\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
}